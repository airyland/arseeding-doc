## Arseeding 实现
### 架构
![arseeding 架构](https://miro.medium.com/max/1400/0*xFUTr38jORpN7uWW)

### 技术实现
从 arseeding server 实现功能可以看出，arseeding server 需要与 arweave 全网节点进行交互，来实现用户数据全网广播和从全网获取数据的基础能力。
所以 arseeding server 需要获取到 arweave 全网节点的 ip 地址。
arweave node 提供了 `/peers` 接口用于获取该节点连接的 peers ip。arseeding server 通过该接口维护了一套高可用的 arweave ip 列表。

#### 广播需要上链的交易
arseeding server 接收到用户提交的 arTx 和 data 之后，通过使用 `goar` 实现的 `uploader` 方法把交易 submit 到每一个节点。
#### 广播链上交易 data
arseeding server 接收到用户提交的 arId 之后，会从 arweave network 上拉取 arId 对应的 data，然后通过 `goar` 实现的 `uplaoder` 方法把 data 广播到所有的节点。
#### 拉取交易 data
Arseeding server 接收到用户提交的 arId 之后，首先从 arweave.net 网关获取交易 data，如果获取失败，则从全网节点获取交易 data， 直到获取成功为止。
把获取到的 data 存储到数据库，用于用户下次从 server 直接获取交易 data。

#### Chunk 上传下载
为了兼容 arweave http api，arseeding 对 data 进行上传和下载的接口都需要使用 arweave chunk 的方式来实现。
通过查看 arweave http api，需要兼容以下接口：
##### 上传
```go
1. SubmintTransaction(tx);
tx struct:
  {
				Format    int    `json:"format"`
        ID        string `json:"id"`
        LastTx    string `json:"last_tx"`
        Owner     string `json:"owner"` // utils.Base64Encode(wallet.PubKey.N.Bytes())
        Tags      []Tag  `json:"tags"`
        Target    string `json:"target"`
        Quantity  string `json:"quantity"`
        Data      string `json:"data"` // base64.encode // allways is null
        DataSize  string `json:"data_size"`
        DataRoot  string `json:"data_root"`
        Reward    string `json:"reward"`
        Signature string `json:"signature"`
  }
if data not null, means dataSize <= 256 * 1024, so not need to submint chunk. then arseeding receive this tx, should self generate chunk by tx.Data.

2. SubmintChunks(getChunk);
getChunk struct:
	{
			DataRoot string `json:"data_root"` // tx data root
      DataSize string `json:"data_size"` // tx data size
      DataPath string `json:"data_path"` // chunk data path; ignore
      Offset   string `json:"offset"`    // chunk offset on tx data
      Chunk    string `json:"chunk"`     // chunk data content
	}
```
##### 下载
```go
1. getTransactionOffset(txId);
return struct:
  {
    Size   string `json:"size"` // txId dataSize
    Offset string `json:"offset"` // all disk file data end offSet
  }

2. getChunkData(chunkStartOffset) // offset is all disk file data offset
return chunk data

chunkStartOffset = txDataStartOffset + len(downloadedChunks)
```
##### Store chunk
```go
arseeding 接收到每个 getChunk 之后，需要计算出 chunkoffset，计算方法如下:

arseeding getChunk -->

 if exist chunk.dataroot+chunk.datasize; 

Search txDataEndOffset from db;

else 

generate txDataEndOffset; ==> current txDataEndOffset + chunk.dataSize

Store db; ==> key:  chunk.dataroot+chunk.datasize; val: txDataEndOffset

// generate chunkStartOffset

key: getChunk.DataSize + getChunk.DataRoot ; val: txDataEndOffset

txDataStartOffset = txDataEndOffset - txDataSize + 1

chunkEndOffset = txDataStartOffset + getChunk.offset

chunkStartOffset = chunkEndOffset - len(getChunk.Chunk)

Key: chunkStartOffset; val: getChunk
```
流程图如下：   

![store chunk](https://miro.medium.com/max/1400/1*9-bhKBR932wKtCXT-Zbx-w.jpeg)
